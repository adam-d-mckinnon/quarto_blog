{
  "hash": "9e855d29000b4e6f8bdf4492e72caf8a",
  "result": {
    "markdown": "---\ntitle: 'Creating Synthetic People Analytics Data'\ndate: 2023-09-10\ndescription: \"Simple methods for creating people analytics data that you can reuse in your context.\"\nauthor: \n    - name: Stephen Pearce\n    - name: Adam D McKinnon\ncategories: [Synthetic Data, People Analytics, R]\nimage: \"maxim-berg-Ac02zYZs22Y-unsplash.jpg\"\ntitle-block-banner: true\ndraft: false\n---\n\n::: {.cell code_folding='false'}\n::: {.cell-output-display}\n![[Photo by Maxim Berg on Unsplash](https://unsplash.com/@maxberg).](maxim-berg-Ac02zYZs22Y-unsplash.jpg){width=100%}\n:::\n:::\n\n\n<br>\n\nPractising people analytics methods can be difficult in the absence of data. Unfortunately, privacy concerns associated with employee data can make accessing datasets difficult. As a consequence, it can be useful for analysts, both novice and seasoned, to be able to generate synthetic datatsets for testing and explaining analytical methods.\n\nThe current article focuses on the generation of synthetic data using R. We will examine the generation of the following two datasets:\n\n1.  **A basic random dataset; and**\n2.  **Creating multiple relationships between variables.**\n\nWe have approached the above steps in a \"recursive\" fashion. By this we mean that we have developed functions that you can use \"as-is\", or modify, to create synthetic datasets in your own context.\n\n<br>\n\n# 1. A basic random dataset\n\nWhen the dataset requirements are simple we can use R's inbuilt random generators. This can be done in one of two ways:\n\n1.  sampling from a statistical distribution using the \\`rnorm\\` function (e.g., for a random value from a Normal distribution). This may be appropriate when creating a continuous variable such as age, tenure, or wage.\n\n2.  sampling from a defined list of options and probabilities with \\`sample\\`. This is more appropriate when creating nominal variables in the dataset such as gender, job family, or location.\n\nUsing a combination of these functions, which we do in all three datasets in this article, we can generate synthetic data that approximates real world data.\n\n<br>\n\n## Explanation\n\nThis R code below defines a function named \\`generate_basic_data\\` that creates a dataset with 7 variables. You specify the number of rows you want in the dataset by passing a value to the \\`num_rows\\` parameter when you call the function.\n\nHere's a step-by-step explanation:\n\n### 1. Function Definition:\n\nThe line \\`generate_basic_data \\<- function(num_rows){ ... }\\` creates a function named \\`generate_basic_data\\`. When you want to use this function later (see the last line of code in the block), you'll tell it how many rows you want by providing a number for \\`num_rows\\`.\n\n### 2. Custom Sample Function:\n\nInside the function, there's a nested helper function named \\`sample_replace\\`. This helper function makes it easier to sample values repeatedly from a given list, with the possibility of repeating values.\n\n### 3. Creating the Dataset:\n\nThe \\`tibble\\` (i.e., 'Tidy' terminology for a data frame) function creates a table of data (similar to an Excel sheet with rows and columns). Each line within this function is defining a column for our table:\n\n-   **`id`**: Just a sequential number from 1 to the number of rows you've asked for. Think of this as a unique identifier for each row.\n\n-   **`age`**: Generates random ages that are normally distributed with an average age of 40 and a standard deviation of 5. This means most ages will be close to 40, but there will be some variation.\n\n-   **`hire_date`**: Randomly selects dates between January 1, 1990, and today. Since \\`sample_replace\\` is used, some dates might be repeated in different rows.\n\n-   **`job_family`**: Randomly selects a job family from the choices \"Engineering\", \"Sales\", and \"Administration\". There's a 60% chance of picking \"Engineering\", 25% chance for \"Sales\", and 15% for \"Administration\".\n\n-   **`contract_type`**: Randomly selects contract type status. \"Full Time\" will be picked 90% of the time, while \"Part Time\" will be picked 10% of the time.\n\n-   `employment_type`: Randomly selects the employment type. \"Permanent\" jobs will appear 70% of the time, while \"Contract\" jobs will appear 30% of the time.\n\n-   `state`: Randomly selects a state from \"VIC\", \"NSW\", and \"QLD\" with respective probabilities of 50%, 30%, and 20%.\n\nOnce you run the function, for example \\`generate_basic_data(100)\\`, it will generate a dataset with 100 rows, filled with the kinds of values described above. In essence, this function is useful for generating a synthetic dataset about employees, including information about their ages, hiring dates, job families, employment types, etc.\n\nClick on the word `code` below to see the code being used.\n\n<br>\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# libraries\nlibrary(dplyr)\nlibrary(purrr)\nlibrary(lubridate)\nlibrary(ggplot2)\n\n\n\n# create a function that will generate 7 variables with fixed responses\ngenerate_basic_data <- function(num_rows){\n  \n    \n  sample_replace <- function(x, prob = NULL) {\n    base::sample(x = x, prob = prob, size = num_rows, replace = T)\n  }\n\n\ntibble::tibble(\n    id              = 1:num_rows,\n    age             = rnorm(num_rows, mean = 40, sd = 5),\n    hire_date       = sample_replace(seq.Date(from = dmy(\"01/01/1990\"), to = today(), by = \"1 day\")),\n    job_family      = sample_replace(c(\"Engineering\", \"Sales\", \"Administration\"), prob = c(0.6,0.25, 0.15)),\n    contract_type   = sample_replace(c(\"Full Time\", \"Part Time\"), prob = c(0.9, 0.1)),\n    employment_type = sample_replace(c(\"Permanent\", \"Contract\"), prob = c(0.7,0.3)),\n    state           = sample_replace(c(\"VIC\",\"NSW\",\"QLD\"), prob = c(0.5, 0.3, 0.2))\n  )\n}\n\n\n# generate 10 rows of data\ngenerate_basic_data(num_rows = 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 10 Ã— 7\n      id   age hire_date  job_family     contract_type employment_type state\n   <int> <dbl> <date>     <chr>          <chr>         <chr>           <chr>\n 1     1  40.4 1999-02-13 Engineering    Full Time     Contract        QLD  \n 2     2  49.5 2009-06-29 Engineering    Full Time     Contract        VIC  \n 3     3  30.4 2018-02-14 Administration Full Time     Permanent       NSW  \n 4     4  35.6 2000-09-26 Engineering    Full Time     Permanent       QLD  \n 5     5  40.2 1993-09-17 Sales          Full Time     Permanent       VIC  \n 6     6  39.4 1994-12-20 Engineering    Full Time     Contract        VIC  \n 7     7  37.5 2009-08-17 Sales          Part Time     Permanent       NSW  \n 8     8  33.5 2014-07-11 Administration Full Time     Contract        VIC  \n 9     9  42.4 2014-01-15 Engineering    Full Time     Contract        QLD  \n10    10  42.5 1999-12-25 Sales          Full Time     Permanent       VIC  \n```\n:::\n:::\n\n\n<br>\n\n<br>\n\n# 2. Creating multiple relationships between variables\n\nIf you are trying to create something that has similar properties to a real dataset, perform an exploratory analysis to understand what correlations are present in the existing data and decide which are relevant for your purpose (i.e., those you want to replicate). Then, we will need to adjust the data generation code to take these differences into account.We will need to create a separate data generation function for each correlated variable, but it is necessary if we want these observed interactions.\n\nFor example, say the main office for our example company was in Victoria. We would expect the administrative staff to be more likely to work there rather than being randomly distributed across the states. To make this work we will need to change how we randomly select a state to be dependent on the job family.\n\n<br>\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsample_state <- function(job) {\n  # Different State probabilities depending on job family\n  prob_for_family <- list(\n    \"Engineering\" = c(0.5, 0.3, 0.2),\n    \"Sales\" = c(0.5, 0.3, 0.2),\n    \"Administration\" = c(0.8, 0.1, 0.1)\n  )\n\n  # Randomly select the state using the per-job probabilities\n  map_chr(\n    job, \n    ~sample(c(\"VIC\",\"NSW\",\"QLD\"), size = 1, prob = prob_for_family[[.]])\n    )\n}\n```\n:::\n\n\n<br>\n\nThe first part of this process is to create a way to adjust the state probability weightings based on a job family. We can keep things simple in this example by using a named list where the names are the three job families and the values are the probabilities to select each state for that job family. Here, we have left the Engineering and Sales families at 50% VIC, 30% NSW, and 20% QLD from the original example but changed the Administration family to be 80%/10%/10% respectively.\n\nNext, we randomly generate the state data. In order to change the probability weightings each time we will use \\`map_chr\\` to apply our sample function over the job families, randomly selecting one state each time, but using the probabilities we defined above.\n\n<br>\n\n## More complex interactions\n\nThis same approach can be extended as the interactions become more complex. For example, we could imagine a scenario in which employment type is dependent on \\*both\\* the hire date and the job family. How would we generate a data set in which more recent hires (\\\\\\<5 years) are more likely to be on short-term contracts, as are Sales staff.\n\n<br>\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsample_employment <- function(hired, job) {\n    # Probability map of Permanent/Contract employment for combinations of \n    # new/old hires and job family\n    prob_map <- list(\n      new_hire = list(\n        \"Engineering\" = c(0.7, 0.3),\n        \"Sales\" = c(0.4, 0.6),\n        \"Administration\" = c(0.7, 0.3)\n      ),\n      old_hire = list(\n        \"Engineering\" = c(0.9, 0.1),\n        \"Sales\" = c(0.7, 0.3),\n        \"Administration\" = c(0.9, 0.1)\n      )\n    )\n \n    hire_status = ifelse(\n      time_length(hired %--% today(), \"years\") < 5, \n      \"new_hire\", \n      \"old_hire\"\n    )\n    \n    map2_chr(\n      hire_status, job, \n      ~sample(c(\"Permanent\", \"Contract\"), size = 1, prob = prob_map[[.x]][[.y]])\n    )\n  }\n```\n:::\n\n\n<br>\n\nWhile a bit more involved to determine the probability weightings than the previous example, the overall structure remains the same.\n\n## Making use of it\n\nTo bring it all together, we can now swap out how we randomly selected state and employment type in the first basic example with our two functions above that randomly generate data dependent on other data columns. These other data columns are generated earlier in the process and then passed along to our new functions.\n\n<br>\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngenerate_complex_data <- function(num_rows) {\n  sample_replace <- function(x, prob = NULL) {\n    sample(x = x, prob = prob, size = num_rows, replace = T)\n  }\n  \ntibble::tibble(\n    ID = 1:num_rows,\n    age = rnorm(num_rows, mean = 40, sd = 5),\n    hire_date = sample_replace(seq.Date(from = dmy(\"01/01/1990\"), to = today(), by = \"1 day\")),\n    job_family = sample_replace(c(\"Engineering\", \"Sales\", \"Administration\"), prob = c(0.6,0.25, 0.15)),\n    engagement = sample_replace(c(\"Full Time\", \"Part Time\"), prob = c(0.9, 0.1)),\n    employment = sample_employment(hire_date, job_family),\n    state = sample_state(job_family) \n  )\n}\n\ngenerate_complex_data(num_rows = 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 10 Ã— 7\n      ID   age hire_date  job_family     engagement employment state\n   <int> <dbl> <date>     <chr>          <chr>      <chr>      <chr>\n 1     1  36.0 1992-08-23 Engineering    Full Time  Permanent  VIC  \n 2     2  40.7 2015-08-24 Engineering    Full Time  Permanent  NSW  \n 3     3  47.0 1996-03-22 Engineering    Full Time  Permanent  VIC  \n 4     4  45.5 2007-08-25 Engineering    Full Time  Permanent  NSW  \n 5     5  39.0 2001-01-06 Administration Full Time  Permanent  VIC  \n 6     6  42.2 2010-12-30 Sales          Full Time  Permanent  VIC  \n 7     7  44.1 2013-10-04 Engineering    Full Time  Permanent  NSW  \n 8     8  39.5 2018-03-08 Engineering    Full Time  Permanent  VIC  \n 9     9  33.4 2000-10-05 Engineering    Full Time  Permanent  NSW  \n10    10  40.3 2017-05-13 Engineering    Full Time  Permanent  NSW  \n```\n:::\n:::\n\n\n<br>\n\nThis produces a randomised data set with our desired characteristics that can then be saved and reused later.\n\n<br>\n\n## Conclusion\n\nThe approach shown here works well enough when there are a relatively small number of variables and interactions that you need to account for. It is capable of being expanded by creating extra data generating functions however at some point things will become challenging to maintain. Once your needs for synthetic data have outgrown this approach, there are alternatives that may be worth exploring. The \\[fabricatr\\] (https://declaredesign.org/r/fabricatr/) package provides a method to generate synthetic datasets with quite sophisticated interactions between variables. Or if you have a specific real dataset whose characteristics you are looking to create, the \\[synthpop\\](https://www.synthpop.org.uk) package may be appropriate.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}